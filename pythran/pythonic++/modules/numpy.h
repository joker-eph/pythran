#ifndef PYTHONIC_MODULE_NUMPY_H
#define PYTHONIC_MODULE_NUMPY_H

#include <vector>
#include <cmath>
#include <cstdint>

#define NUMPY_EXPR_TO_NDARRAY0(fname)\
    template<class Op, class Arg, class... Types>\
        auto fname(core::numpy_uexpr<Op,Arg> const& expr, Types... others)\
            -> decltype(fname(typename core::numpy_expr_to_ndarray<core::numpy_uexpr<Op,Arg>>::type(expr), std::forward<Types>(others)...)) \
    {\
        return fname(typename core::numpy_expr_to_ndarray<core::numpy_uexpr<Op,Arg>>::type(expr), std::forward<Types>(others)...);\
    }\
    template<class Op, class Arg0, class Arg1, class... Types>\
        auto fname(core::numpy_expr<Op,Arg0, Arg1> const& expr, Types... others)\
            -> decltype(fname(typename core::numpy_expr_to_ndarray<core::numpy_expr<Op,Arg0,Arg1>>::type(expr), std::forward<Types>(others)...)) \
    {\
        return fname(typename core::numpy_expr_to_ndarray<core::numpy_expr<Op,Arg0, Arg1>>::type(expr), std::forward<Types>(others)...);\
    }\
    template<class T, class... Types>\
        auto fname(core::list<T> const& expr, Types... others)\
            -> decltype(fname(typename core::numpy_expr_to_ndarray<core::list<T>>::type(expr), std::forward<Types>(others)...)) \
    {\
        return fname(typename core::numpy_expr_to_ndarray<core::list<T>>::type(expr), std::forward<Types>(others)...);\
    }

namespace pythonic {
    namespace numpy {

        /* a few classical constants */
        double const pi = 3.141592653589793238462643383279502884;
        double const e = 2.718281828459045235360287471352662498;
        double const nan = std::numeric_limits<double>::quiet_NaN();
        double const inf = std::numeric_limits<double>::infinity();

        /* numpy standard types */
        namespace proxy {
            // these typedefs are not functions, but the default constructor
            // make it legal to write pythonic::proxy::double_
            // as generated by pythran
            // so we put these typedefs in the proxy namespace
            typedef std::complex<double> complex;
            typedef std::complex<float> complex32;
            typedef std::complex<double> complex64;
            typedef std::complex<long double> complex128;
            typedef float float_;
            typedef float float32;
            typedef double float64;
            typedef double float128;
            typedef double double_;
            typedef int8_t int8;
            typedef int16_t int16;
            typedef int32_t int32;
            typedef int64_t int64;
            typedef uint8_t uint8;
            typedef uint16_t uint16;
            typedef uint32_t uint32;
            typedef uint64_t uint64;
        }


       template<class T, class dtype=typename nested_container_value_type<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::type>
          core::ndarray<dtype, nested_container_depth<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::value > array(T&& iterable, dtype d=dtype()) {
              return core::ndarray<dtype, nested_container_depth<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::value >(std::forward<T>(iterable));
          }

       PROXY(pythonic::numpy, array);

       template<class S, class dtype=double>
          core::ndarray<dtype, std::tuple_size<S>::value> zeros(S&& shape, dtype d=dtype()) {
              return core::ndarray<dtype, std::tuple_size<S>::value>(std::forward<S>(shape), dtype(0));
          }

       template<class dtype=double>
          core::ndarray<dtype, 1> zeros(long size, dtype d=dtype()) {
              return zeros(core::make_tuple(size), d);
          }


       PROXY(pythonic::numpy, zeros);

       template<class S, class dtype=double>
          core::ndarray<dtype, std::tuple_size<S>::value> ones(S&& shape, dtype d=dtype()) {
              return core::ndarray<dtype, std::tuple_size<S>::value>(std::forward<S>(shape), dtype(1));
          }

       template<class dtype=double>
          core::ndarray<dtype, 1> ones(long size, dtype d=dtype()) {
              return ones(core::make_tuple(size), d);
          }

       PROXY(pythonic::numpy, ones);

       template<class S, class dtype=double>
          core::ndarray<dtype, std::tuple_size<S>::value> empty(S&& shape, dtype d=dtype()) {
              return core::ndarray<dtype, std::tuple_size<S>::value>(std::forward<S>(shape), None);
          }
       template<class dtype=double>
          core::ndarray<dtype, 1> empty(long size, dtype d=dtype()) {
              return empty(core::make_tuple(size), d);
          }

       PROXY(pythonic::numpy, empty);


       template<class T, class U, class dtype=long>
           core::ndarray<decltype(std::declval<T>()+std::declval<U>()+std::declval<dtype>()), 1> arange(T begin, U end, dtype step=dtype(1))
           {
               typedef decltype(begin+end+step) R;
               size_t size = std::max(R(0), R(std::ceil((end - begin)/step)));
               core::ndarray<R, 1> a(core::make_tuple((long)size), None);
               if(size)
               {
                   auto prev = a.begin(),
                        end = a.end();
                   *prev = begin;
                   for(auto iter = prev + 1; iter!=end; ++iter) {
                       *iter = *prev + step;
                       prev = iter;
                   }
               }
               return a;
           }

       template<class T>
          core::ndarray<T, 1> arange(T end) {
              return arange(T(0), end);
          }
       PROXY(pythonic::numpy, arange);

       template<class T>
          long alen(T&& expr) {
              return expr.shape[0];
          }
       PROXY(pythonic::numpy, alen);

       core::ndarray<double, 1> linspace(double start, double stop, long num=50, bool endpoint = true)
       {
           double step = (stop - start) / (num - (endpoint?1:0)) ;
           return arange(start, stop + (endpoint?step*.5:0), step);
       }

       PROXY(pythonic::numpy, linspace);

       auto logspace(double start, double stop, long num=50, bool endpoint = true, double base=10.0)
           -> decltype(core::power(base, linspace(start, stop, num, endpoint)))
       {
           return core::power(base, linspace(start, stop, num, endpoint));
       }

       PROXY(pythonic::numpy, logspace);

       template<class T, size_t N, class ...S>
           core::ndarray<T, sizeof...(S)> reshape( core::ndarray<T,N> const& expr, S&& ...s) {
               return expr.reshape(core::make_tuple(std::forward<S>(s)...));
           }

       NUMPY_EXPR_TO_NDARRAY0(reshape);

       PROXY(pythonic::numpy, reshape);

       template<class T, size_t N, class dtype=T>
           core::ndarray<dtype,1> cumsum(core::ndarray<T,N> const& expr, dtype d = dtype()) {
               long count = expr.size();
               core::ndarray<dtype,1> cumsumy(core::make_tuple(count), None);
               std::partial_sum(expr.buffer, expr.buffer + count, cumsumy.buffer);
               return cumsumy;
           }

       template<class T, class dtype=T>
           core::ndarray<dtype,1> cumsum(core::ndarray<T,1> const& expr, long axis, dtype d = dtype()) {
               if(axis !=0)
                   throw __builtin__::ValueError("axis out of bounds");
               return cumsum(expr);
           }

       template<class T, size_t N, class dtype=T>
           core::ndarray<dtype,N> cumsum(core::ndarray<T,N> const& expr, long axis, dtype d = dtype()) {
               if(axis<0 || axis >=long(N))
                   throw __builtin__::ValueError("axis out of bounds");

               auto shape = expr.shape;
               core::ndarray<dtype,N> cumsumy(shape, None);
               if(axis==0) {
                   std::copy(expr.buffer, expr.buffer + shape[N-1], cumsumy.buffer);
                   std::transform(cumsumy.begin(), cumsumy.end()-1, expr.begin() + 1, cumsumy.begin() + 1, std::plus<core::ndarray<T,N-1>>());
               }
               else {
                   std::transform(expr.begin(), expr.end(), cumsumy.begin(), [=](core::ndarray<T,N-1> const& e) { return cumsum(e, axis-1, d); });
               }
               return cumsumy;
           }

       PROXY(pythonic::numpy, cumsum);

       template<class T, size_t N>
           T sum(core::ndarray<T,N> const& expr, none_type axis=None) {
               return std::accumulate(expr.buffer, expr.buffer + expr.size(), T(0));
           }

       template<class T>
            T sum( core::ndarray<T,1> const& array, long axis)
            {
                if(axis!=0)
                    throw __builtin__::ValueError("axis out of bounds");
                return sum(array);
            }

       template<class T, size_t N>
            typename core::ndarray<T,N>::value_type sum( core::ndarray<T,N> const& array, long axis)
            {
                if(axis<0 || axis >=long(N))
                    throw __builtin__::ValueError("axis out of bounds");
                auto shape = array.shape;
                if(axis==0)
                {
                    return std::accumulate(array.begin() + 1, array.end(), *array.begin());
                }
                else
                {
                    core::ltuple<long, N-1> shp;
                    std::copy(shape.begin(), shape.end() - 1, shp.begin());
                    core::ndarray<T,N-1> sumy(shp, None);
                    std::transform(array.begin(), array.end(), sumy.begin(), [=](core::ndarray<T,N-1> const& other) {return sum(other, axis-1);});
                    return sumy;
                }
            }

       NUMPY_EXPR_TO_NDARRAY0(sum);
       PROXY(pythonic::numpy, sum);
       template<class E, class dtype=double>
           auto
           mean(E const& expr, none_type axis=None, dtype d=dtype())
           -> decltype(sum(expr)/dtype(expr.size()))
           {
               return sum(expr)/dtype(expr.size());
           }

       PROXY(pythonic::numpy, mean);

       template<class T, size_t N>
           decltype(std::declval<T>()+1.) median(core::ndarray<T,N> const& arr) {
               size_t n = arr.size();
               T* tmp = new T[n];
               std::copy(arr.buffer, arr.buffer + n, tmp);
               std::sort(tmp, tmp + n);
               auto out = (tmp[n/2]+tmp[(n-1)/2])/double(2);
               delete [] tmp;
               return out;
           }

       PROXY(pythonic::numpy, median);

       template<class E>
           typename core::numpy_expr_to_ndarray<E>::type
           nan_to_num(E const& expr) {
               typename core::numpy_expr_to_ndarray<E>::type out(expr.shape, None);
               for(long i=0, n=expr.size(); i<n; ++i) {
                   auto v = expr.at(i);
                   if(pythonic::numpy_expr::ops::isposinf(v))
                       out.at(i) = std::numeric_limits<typename core::numpy_expr_to_ndarray<E>::type::dtype>::max();
                   else if(pythonic::numpy_expr::ops::isneginf(v))
                       out.at(i) = -std::numeric_limits<typename core::numpy_expr_to_ndarray<E>::type::dtype>::max();
                   else if(nt2::is_nan(v))
                       out.at(i) = 0;
                   else out.at(i) = v;
               }
               return out;
           }

       PROXY(pythonic::numpy, nan_to_num);
       template<class E>
           long nanargmin(E&& expr) {
               long sz = expr.size();
               if(not sz) 
                   throw __builtin__::ValueError("empty sequence");
               long i = 0;
               auto e_i = expr.at(i);
               for(; i< sz and nt2::is_nan(e_i) ; ++i) {
                   e_i = expr.at(i);
               }
               if( i < sz) {
                   auto res = e_i;
                   auto index = i;
                   for(; i< sz ; ++i) {
                       auto e_i = expr.at(i);
                       if(e_i< res and not nt2::is_nan(e_i)) {
                           res = e_i;
                           index = i;
                       }
                   }
                   return index;
               }
               else
                   throw __builtin__::ValueError("empty sequence");
           }
       template<class E>
           long nanargmax(E&& expr) {
               long sz = expr.size();
               if(not sz) 
                   throw __builtin__::ValueError("empty sequence");
               long i = 0;
               auto e_i = expr.at(i);
               while(i< sz and nt2::is_nan(e_i)) {
                   e_i = expr.at(++i);
               }
               if( i < sz) {
                   auto res = e_i;
                   auto index = i;
                   for(; i< sz ; ++i) {
                       auto e_i = expr.at(i);
                       if(e_i > res and not nt2::is_nan(e_i)) {
                           res = e_i;
                           index = i;
                       }
                   }
                   return index;
               }
               else
                   throw __builtin__::ValueError("empty sequence");
           }
        PROXY(pythonic::numpy, nanargmax);

        PROXY(pythonic::numpy, nanargmin);

       template<class E>
           auto min(E&& expr) -> typename std::remove_reference<decltype(expr.at(0))>::type {
               long sz = expr.size();
               if(not sz) 
                   throw __builtin__::ValueError("empty sequence");
               auto res = expr.at(0);
               for(long i = 1; i< sz ; ++i) {
                   auto e_i = expr.at(i);
                   if(e_i< res)
                       res = e_i;
               }
               return res;
           }
       template<class E>
           auto max(E&& expr) -> typename std::remove_reference<decltype(expr.at(0))>::type {
               long sz = expr.size();
               if(not sz) 
                   throw __builtin__::ValueError("empty sequence");
               auto res = expr.at(0);
               for(long i = 1; i< sz ; ++i) {
                   auto e_i = expr.at(i);
                   if(e_i > res)
                       res = e_i;
               }
               return res;
           }

       template<class T>
           T min(core::ndarray<T,1> const& array, long axis) {
               if(axis!=0)
                   throw __builtin__::ValueError("axis out of bounds");
               return min(array);
           }

       template<class T>
           T max(core::ndarray<T,1> const& array, long axis) {
               if(axis!=0)
                   throw __builtin__::ValueError("axis out of bounds");
               return max(array);
           }

       template<class T, size_t N>
           typename core::ndarray<T,N>::value_type min(core::ndarray<T,N> const& array, long axis)
           {
               if(axis<0 || axis >=long(N))
                   throw __builtin__::ValueError("axis out of bounds");
               auto shape = array.shape;
               if(axis==0)
               {
                   core::ltuple<long, N-1> shp;
                   size_t size = 1;
                   for(auto i= shape.begin() + 1, j = shp.begin(); i<shape.end(); i++, j++)
                        size*=(*j = *i);
                   core::ndarray<T,N-1> a(shp, None);
                   auto a_iter = a.buffer;
                   std::copy(array.buffer, array.buffer + size, a_iter);
                   for(auto i = array.begin() + 1; i<array.end(); i++)
                   {
                       auto next_subarray = *i;  //we need this variable to keep this ndarray alive while iter is used
                       auto iter = next_subarray.buffer,
                            iter_end = next_subarray.buffer + next_subarray.size();
                       auto k = a_iter;
                       for(auto j = iter; j<iter_end; j++, k++)
                           *k=std::min(*k,*j);
                    }
                    return a;
               }
               else
               {
                   core::ltuple<long, N-1> shp;
                   std::copy(shape.begin(), shape.end() - 1, shp.begin());
                   core::ndarray<T,N-1> miny(shp, None);
                   std::transform(array.begin(), array.end(), miny.begin(), [=](core::ndarray<T,N-1> const& other) {return min(other, axis-1);});
                   return miny;
               }
           }
       template<class T, size_t N>
           typename core::ndarray<T,N>::value_type max(core::ndarray<T,N> const& array, long axis)
           {
               if(axis<0 || axis >=long(N))
                   throw __builtin__::ValueError("axis out of bounds");
               auto shape = array.shape;
               if(axis==0)
               {
                   core::ltuple<long, N-1> shp;
                   size_t size = 1;
                   for(auto i= shape.begin() + 1, j = shp.begin(); i<shape.end(); i++, j++)
                        size*=(*j = *i);
                   core::ndarray<T,N-1> a(shp, None);
                   auto a_iter = a.buffer;
                   std::copy(array.buffer, array.buffer + size, a_iter);
                   for(auto i = array.begin() + 1; i<array.end(); i++)
                   {
                       auto next_subarray = *i;  //we need this variable to keep this ndarray alive while iter is used
                       auto iter = next_subarray.buffer,
                            iter_end = next_subarray.buffer + next_subarray.size();
                       auto k = a_iter;
                       for(auto j = iter; j<iter_end; j++, k++)
                           *k=std::max(*k,*j);
                    }
                    return a;
               }
               else
               {
                   core::ltuple<long, N-1> shp;
                   std::copy(shape.begin(), shape.end() - 1, shp.begin());
                   core::ndarray<T,N-1> miny(shp, None);
                   std::transform(array.begin(), array.end(), miny.begin(), [=](core::ndarray<T,N-1> const& other) {return max(other, axis-1);});
                   return miny;
               }
           }


       PROXY(pythonic::numpy, min);
       PROXY(pythonic::numpy, max);

       template<class E>
           bool all(E&& expr) {
               long sz = expr.size();
               for(long i=0;i < sz ; ++i)
                   if( not expr.at(i) )
                       return false;
               return true;
           }

       template<class T>
            T all( core::ndarray<T,1> const& array, long axis)
            {
                if(axis!=0)
                    throw __builtin__::ValueError("axis out of bounds");
                return all(array);
            }

       template<class T, size_t N>
            typename core::ndarray<T,N>::value_type all( core::ndarray<T,N> const& array, long axis)
            {
                if(axis<0 || axis >=long(N))
                    throw __builtin__::ValueError("axis out of bounds");
                auto shape = array.shape;
                if(axis==0)
                {
                    core::ltuple<long, N-1> shp;
                    size_t size = 1;
                    for(auto i= shape.begin() + 1, j = shp.begin(); i<shape.end(); i++, j++)
                        size*=(*j = *i);
                    core::ndarray<T,N-1> a(shp, None);
                    auto a_iter = a.buffer;
                    std::copy(array.buffer, array.buffer + size, a_iter);
                    for(auto i = array.begin() + 1; i<array.end(); i++)
                    {
                        auto next_subarray = *i;  //we need this variable to keep this ndarray alive while iter is used
                        auto iter = next_subarray.buffer,
                             iter_end = next_subarray.buffer + next_subarray.size();
                        auto k = a_iter;
                        for(auto j = iter; j<iter_end; j++, k++)
                            *k=*k and *j;
                    }
                    return a;
                }
                else
                {
                    core::ltuple<long, N-1> shp;
                    std::copy(shape.begin(), shape.end() - 1, shp.begin());
                    core::ndarray<T,N-1> ally(shp, None);
                    std::transform(array.begin(), array.end(), ally.begin(), [=](core::ndarray<T,N-1> const& other) {return all(other, axis-1);});
                    return ally;
                }
            }

        PROXY(pythonic::numpy, all);

        template<class U, class V>
            bool allclose(U&& u, V&& v, double rtol=1e-5, double atol=1e-8) {
                long u_s = u.size(),
                     v_s = v.size();
                if( u_s == v_s ) {
                    for(long i=0;i < u_s; ++i) {
                        auto v_i = v.at(i);
                        if( std::abs(u.at(i)-v_i) > (atol + rtol * std::abs(v_i)))
                            return false;
                    }
                    return true;
                }
                return false;
            }

        PROXY(pythonic::numpy, allclose);

        template<class... Types>
            auto alltrue(Types&&... types) -> decltype(all(std::forward<Types>(types)...)) {
                return all(std::forward<Types>(types)...);
            }

        PROXY(pythonic::numpy, alltrue);

        template<class... Types>
            auto amax(Types&&... types) -> decltype(max(std::forward<Types>(types)...)) {
                return max(std::forward<Types>(types)...);
            }

        PROXY(pythonic::numpy, amax);

        template<class... Types>
            auto amin(Types&&... types) -> decltype(min(std::forward<Types>(types)...)) {
                return min(std::forward<Types>(types)...);
            }

        PROXY(pythonic::numpy, amin);

       template<class E>
           bool any(E&& expr) {
               long sz = expr.size();
               for(long i=0;i < sz ; ++i)
                   if( expr.at(i) )
                       return true;
               return false;
           }

       template<class T>
            T any( core::ndarray<T,1> const& array, long axis)
            {
                if(axis!=0)
                    throw __builtin__::ValueError("axis out of bounds");
                return any(array);
            }

       template<class T, size_t N>
            typename core::ndarray<T,N>::value_type any( core::ndarray<T,N> const& array, long axis)
            {
                if(axis<0 || axis >=long(N))
                    throw __builtin__::ValueError("axis out of bounds");
                auto shape = array.shape;
                if(axis==0)
                {
                    core::ltuple<long, N-1> shp;
                    size_t size = 1;
                    for(auto i= shape.begin() + 1, j = shp.begin(); i<shape.end(); i++, j++)
                        size*=(*j = *i);
                    core::ndarray<T,N-1> a(shp, None);
                    auto a_iter = a.buffer;
                    std::copy(array.buffer, array.buffer + size, a_iter);
                    for(auto i = array.begin() + 1; i<array.end(); i++)
                    {
                        auto next_subarray = *i;  //we need this variable to keep this ndarray alive while iter is used
                        auto iter = next_subarray.buffer,
                             iter_end = next_subarray.buffer + next_subarray.size();
                        auto k = a_iter;
                        for(auto j = iter; j<iter_end; j++, k++)
                            *k=*k or *j;
                    }
                    return a;
                }
                else
                {
                    core::ltuple<long, N-1> shp;
                    std::copy(shape.begin(), shape.end() - 1, shp.begin());
                    core::ndarray<T,N-1> ally(shp, None);
                    std::transform(array.begin(), array.end(), ally.begin(), [=](core::ndarray<T,N-1> const& other) {return any(other, axis-1);});
                    return ally;
                }
            }

        PROXY(pythonic::numpy, any);


        template<class T, unsigned long N, class... C>
            core::ndarray<T,N> _transpose(core::ndarray<T,N> const & a, long const l[N])
            {
                auto shape = a.shape;
                core::ltuple<long, N> shp;
                for(unsigned long i=0; i<N; i++)
                    shp[i] = shape[l[i]];

                core::ndarray<T,N> new_array(shp, None);

                std::array<long, N> new_strides;
                new_strides[N-1] = 1;
                std::transform(new_strides.rbegin(), new_strides.rend() -1, shp.rbegin(), new_strides.rbegin() + 1, std::multiplies<long>());

                std::array<long, N> old_strides;
                old_strides[N-1] = 1;
                std::transform(old_strides.rbegin(), old_strides.rend() -1, shape.rbegin(), old_strides.rbegin() + 1, std::multiplies<long>());

                auto iter = a.buffer,
                     iter_end = a.buffer + a.size();
                for(long i=0; iter!=iter_end; ++iter, ++i) {
                    long offset = 0;
                    for(unsigned long s=0; s<N; s++)
                        offset += ((i/old_strides[l[s]]) % shape[l[s]])*new_strides[s];
                    new_array.buffer[offset] = *iter;
                }

                return new_array;
            }

        template<class T, size_t N>
            core::ndarray<T,N> transpose(core::ndarray<T,N> const & a)
            {
                long t[N];
                for(unsigned long i = 0; i<N; i++)
                    t[N-1-i] = i;
                return _transpose(a, t);
            }
        template<class T, size_t N, size_t M>
            core::ndarray<T,N> transpose(core::ndarray<T,N> const & a, core::ltuple<long, M> const& t)
            {
                static_assert(N==M, "axes don't match array");

                long val = t[M-1];
                if(val>=long(N))
                    throw __builtin__::ValueError("invalid axis for this array");
                return _transpose(a, &t[0]);
            }

        NUMPY_EXPR_TO_NDARRAY0(transpose);
        PROXY(pythonic::numpy, transpose);
#if 0
        template<class... T, class type>
            core::ndarray<type,sizeof...(T)> build_cst_array_from_list(type cst, core::list<type> const& prev_l, type const& val, T const& ...l)
            {
                return core::ndarray<type, sizeof...(l)>({l...}, cst);
            }

        template<class... T, class type>
            core::ndarray<typename finalType<type>::Type, depth<core::list<type>>::Value + sizeof...(T)> build_cst_array_from_list(typename finalType<type>::Type cst, core::list<core::list<type> > const &prev_l, core::list<type> const& l, T const& ...s)
            {
                return build_cst_array_from_list(cst, l, l[0], s..., (size_t)l.size());
            }

        template<class type>
            core::ndarray<typename finalType<type>::Type, depth<core::list<type>>::Value> ones_like(core::list<type> const& l)
            {
                return build_cst_array_from_list(1, l, l[0], (size_t)l.size());
            }

        PROXY(pythonic::numpy, ones_like);

        template<class... T, class type>
            core::ndarray<type,sizeof...(T)> build_not_init_array_from_list(core::list<type> const& prev_l, type const& val, T ...l)
            {
                return core::ndarray<type, sizeof...(l)>({l...});
            }

        template<class... T, class type>
            core::ndarray<typename finalType<type>::Type, depth<core::list<type>>::Value + sizeof...(T)> build_not_init_array_from_list(core::list<core::list<type> > const &prev_l, core::list<type> const& l, T ...s)
            {
                return build_not_init_array_from_list(l, l[0], s..., (size_t)l.size());
            }

        template<class type>
            core::ndarray<typename finalType<type>::Type, depth<core::list<type>>::Value> zeros_like(core::list<type> const& l)
            {
                return build_cst_array_from_list(0, l, l[0], (size_t)l.size());
            }
        PROXY(pythonic::numpy, zeros_like);

        template<class type>
            core::ndarray<typename finalType<type>::Type, depth<core::list<type>>::Value> empty_like(core::list<type> const& l)
            {
                return build_not_init_array_from_list(l, l[0], (size_t)l.size());
            }

        PROXY(pythonic::numpy, empty_like);
#endif


#define NP_PROXY(name)\
        using nt2::name;\
        using pythonic::core::name;\
        PROXY(pythonic::numpy, name)
#define NP_PROXY_ALIAS(name, alias)\
        ALIAS(alias, name)\
        using pythonic::core::name;\
        PROXY(pythonic::numpy, name)
#define NP_PROXY_OP(name)\
        using pythonic::numpy_expr::ops::name;\
        using pythonic::core::name;\
        PROXY(pythonic::numpy, name)

        NP_PROXY(abs);

        NP_PROXY_ALIAS(absolute, nt2::abs);

        NP_PROXY_OP(add);

        NP_PROXY_ALIAS(angle_in_deg, pythonic::numpy_expr::ops::angle_in_deg);

        NP_PROXY_ALIAS(angle_in_rad, pythonic::numpy_expr::ops::angle_in_rad);

        template<class T>
            auto angle(T const& t, bool in_deg) -> decltype(typename core::numpy_expr_to_ndarray<T>::type(angle_in_rad(typename core::to_ndarray<T>::type(t)))) {
                if(in_deg)
                    return typename core::numpy_expr_to_ndarray<T>::type(angle_in_deg(typename core::to_ndarray<T>::type(t)));
                else
                    return typename core::numpy_expr_to_ndarray<T>::type(angle_in_rad(typename core::to_ndarray<T>::type(t)));
            }
        template<class T>
            auto angle(T const& t) -> typename std::enable_if<not core::is_numpy_expr<T>::value,decltype(angle(t,false))>::type {
                    return angle(t,false);
            }
        PROXY(pythonic::numpy, angle);

        template<class T, size_t N, class F>
            core::ndarray<
                typename std::remove_cv<
                    typename std::remove_reference<
                        decltype(
                                std::declval<T>()
                                +
                                std::declval<typename nested_container_value_type<F>::type>())
                        >::type
                    >::type,
                1> append(core::ndarray<T,N> const& nto, F const& data) {
                    typename core::numpy_expr_to_ndarray<F>::type ndata(data);
                    long nsize = nto.size() + ndata.size();
                    core::ndarray<
                        typename std::remove_cv<
                            typename std::remove_reference<
                                decltype(
                                        std::declval<T>()
                                        +
                                        std::declval<typename nested_container_value_type<F>::type>())
                                >::type
                            >::type,
                        1> out(core::make_tuple(nsize), None);
                    size_t i=0;
                    for(i=0;i<nto.size();i++)
                        out.at(i) = nto.at(i);
                    for(size_t j=0;j<ndata.size();j++)
                        out.at(i+j) = ndata.at(j);
                    return out;
                }
        template<class T, class F>
            core::ndarray<
                typename std::remove_cv<
                    typename std::remove_reference<
                        decltype(
                                std::declval<typename nested_container_value_type<core::list<T>>::type>()
                                +
                                std::declval<typename nested_container_value_type<F>::type>())
                        >::type
                    >::type,
                1> append(core::list<T> const& to, F const& data) {
                    return append(typename core::numpy_expr_to_ndarray<core::list<T>>::type(to), data);
                }

        PROXY(pythonic::numpy, append);

       template<class E>
           long argmin(E&& expr) {
               long sz = expr.size();
               if(not sz) 
                   throw __builtin__::ValueError("empty sequence");
               auto res = expr.at(0);
               long index = 0;
               for(long i = 1; i< sz ; ++i) {
                   auto e_i = expr.at(i);
                   if(e_i< res) {
                       res = e_i;
                       index = i;
                   }
               }
               return index;
           }
       template<class E>
           long argmax(E&& expr) {
               long sz = expr.size();
               if(not sz) 
                   throw __builtin__::ValueError("empty sequence");
               auto res = expr.at(0);
               long index = 0;
               for(long i = 1; i< sz ; ++i) {
                   auto e_i = expr.at(i);
                   if(e_i > res) {
                       res = e_i;
                       index = i;
                   }
               }
               return index;
           }
        PROXY(pythonic::numpy, argmax);

        PROXY(pythonic::numpy, argmin);

        template<class T, size_t N>
            core::ndarray<long, N> argsort(core::ndarray<T,N> const& a) {
                size_t last_axis = a.shape[N-1];
                size_t n = a.size();
                core::ndarray<long, N> indices(a.shape, None);
                for(long j=0, * iter_indices = indices.buffer, *end_indices = indices.buffer + n;
                        iter_indices != end_indices;
                        iter_indices += last_axis, j+=last_axis)
                {
                    // fill with the original indices
                    std::iota(iter_indices, iter_indices + last_axis, 0L);
                    // sort the index using the value from a
                    std::sort(iter_indices, iter_indices + last_axis,
                            [&a,j](long i1, long i2) {return a.at(j+i1) < a.at(j+i2);});
                }
                return indices;
            }

        PROXY(pythonic::numpy, argsort);

        template<class E>
            typename core::ndarray<long, 2>
            argwhere(E const& expr) {
                typedef typename core::ndarray<long, 2> out_type;
                constexpr long N = core::numpy_expr_to_ndarray<E>::N;
                long sz = expr.size();
                auto eshape = expr.shape;
                long *buffer = new long[N * sz]; // too much memory used
                long *buffer_iter = buffer;
                long real_sz = 0;
                for(long i=0; i< sz; ++i) {
                    if(expr.at(i)) {
                        ++real_sz;
                        long mult = 1;
                        for(long j=N-1; j>0; j--) {
                            buffer_iter[j] = (i/mult)%eshape[j];
                            mult*=eshape[j];
                        }
                        buffer_iter[0] = i/mult;
                        buffer_iter+=N;
                    }
                }
                long shape[2] = { real_sz, N };
                return out_type(buffer, shape, N*real_sz);
            }

        PROXY(pythonic::numpy, argwhere);

        template<class T, size_t N>
            core::ndarray<T,N> around(core::ndarray<T,N> const& a, long decimals=0) {
                return pythonic::core::rint(a * std::pow(T(10),decimals)) / std::pow(T(10), decimals);
            }
        template<class T>
            typename core::numpy_expr_to_ndarray<core::list<T>>::type around(core::list<T> const& l, long decimals=0) {
                return around(typename core::numpy_expr_to_ndarray<core::list<T>>::type(l), decimals);
            }

        PROXY(pythonic::numpy, around);

        template<class T, size_t N>
            core::string array2string(core::ndarray<T,N> const& a) {
                std::ostringstream oss;
                oss << a;
                return core::string(oss.str());
            }

        PROXY(pythonic::numpy, array2string);

        template<class U, class V>
            typename std::enable_if<has_shape<U>::value and has_shape<V>::value,bool>::type array_equal(U const& u, V const&v) {
                if(u.shape == v.shape) {
                    long n = u.size();
                    for(long i=0;i<n;i++)
                        if(u.at(i) != v.at(i))
                            return false;
                    return true;
                }
                return false;
            }
        template<class U, class V>
            typename std::enable_if<has_shape<V>::value,bool>::type array_equal(core::list<U> const& u, V const&v) {
                return array_equal(typename core::numpy_expr_to_ndarray<core::list<U>>::type(u), v);
            }
        template<class U, class V>
            typename std::enable_if<has_shape<U>::value,bool>::type array_equal(U const& u, core::list<V> const&v) {
                return array_equal(u, typename core::numpy_expr_to_ndarray<core::list<V>>::type(v));
            }
        template<class U, class V>
            bool array_equal(core::list<U> const& u, core::list<V> const&v) {
                return array_equal(typename core::numpy_expr_to_ndarray<core::list<U>>::type(u), typename core::numpy_expr_to_ndarray<core::list<V>>::type(v));
            }

        PROXY(pythonic::numpy, array_equal);

        template<class U, class V>
            typename std::enable_if<has_shape<U>::value and has_shape<V>::value,bool>::type array_equiv(U const& u, V const&v) {
                if(u.shape == v.shape) {
                    return array_equal(u,v);
                }
                else if(u.size() > v.size()) {
                    return array_equiv(v,u);
                }
                else if(v.size()%u.size() ==0) {
                    long vs = v.size(),
                         us = u.size();
                    for(long vi = 0; vi < vs ; ) {
                        for(long ui=0;ui<us; ++ui,++vi)
                            if(u.at(ui) != v.at(vi))
                                return false;
                    }
                    return true;
                }
                return false;
            }
        template<class U, class V>
            typename std::enable_if<has_shape<V>::value,bool>::type array_equiv(core::list<U> const& u, V const&v) {
                return array_equiv(typename core::numpy_expr_to_ndarray<core::list<U>>::type(u), v);
            }
        template<class U, class V>
            typename std::enable_if<has_shape<U>::value,bool>::type array_equiv(U const& u, core::list<V> const&v) {
                return array_equiv(u, typename core::numpy_expr_to_ndarray<core::list<V>>::type(v));
            }
        template<class U, class V>
            bool array_equiv(core::list<U> const& u, core::list<V> const&v) {
                return array_equiv(typename core::numpy_expr_to_ndarray<core::list<U>>::type(u), typename core::numpy_expr_to_ndarray<core::list<V>>::type(v));
            }

        PROXY(pythonic::numpy, array_equiv);

        template<class T, size_t N>
            core::list<core::ndarray<T,N>> array_split(core::ndarray<T,N> const& a, long nb_split) {
                long sz = std::distance(a.begin(), a.end());
                long n = (sz + nb_split -1 ) / nb_split;
                long end = n * nb_split;
                long nb_full_split = nb_split;
                if(end != sz) nb_full_split -= (end -sz);
                core::list<core::ndarray<T,N>> out(nb_split);
                long index = 0;
                for(long i=0;i<nb_full_split; i++, index+=n) 
                    out[i] = core::ndarray<T,N>(a[core::slice(index, index+n)]);
                for(long i=nb_full_split;i<nb_split; i++, index+=(n-1)) 
                    out[i] = core::ndarray<T,N>(a[core::slice(index, index + n - 1)]);

                return out;
            }

        template<class T, size_t N, class I>
            typename std::enable_if<is_iterable<I>::value, core::list<core::ndarray<T,N>>>::type
            array_split(core::ndarray<T,N> const& a, I const& split_mask) {
                long sz = std::distance(a.begin(), a.end());
                core::list<core::ndarray<T,N>> out(1+split_mask.size());
                long index = 0;
                auto inserter = out.begin();
                for(auto next_index: split_mask) {
                    *inserter++ = core::ndarray<T,N>(a[core::slice(index, next_index)]);
                    index = next_index;
                }
                *inserter = core::ndarray<T,N>(a[core::slice(index, sz)]);
                return out;
            }

        PROXY(pythonic::numpy, array_split);
        template<class T, size_t N>
            core::string array_str(core::ndarray<T,N> const& a) {
                std::ostringstream oss;
                oss << a;
                return core::string(oss.str());
            }

        PROXY(pythonic::numpy, array_str);

        template<class E>
            struct _asarray {
                template<class... Types>
                    auto operator()(Types&&... args) -> decltype(array(std::forward<Types>(args)...)) {
                        return array(std::forward<Types>(args)...);
                    }
            };
        template<class T, size_t N>
            struct _asarray<core::ndarray<T,N>> {
                template<class F>
                    core::ndarray<T,N> operator()(F&& a) {
                        return a;
                    }
            };

        template<class E, class... Types>
            auto asarray(E&& e, Types&&... args) -> decltype(_asarray<typename std::remove_cv<typename std::remove_reference<E>::type>::type>()(std::forward<E>(e), std::forward<Types>(args)...)) {
                return _asarray<typename std::remove_cv<typename std::remove_reference<E>::type>::type>()(std::forward<E>(e), std::forward<Types>(args)...);
            }

        PROXY(pythonic::numpy, asarray);

        template<class... Types>
            auto asarray_chkfinite(Types&&... args) -> decltype(asarray(std::forward<Types>(args)...)) {
                auto out = asarray(std::forward<Types>(args)...);
                for(auto iter = out.buffer, end = out.buffer + out.size();
                        iter != end;
                        ++iter)
                {
                    if(not std::isfinite(*iter))
                        throw __builtin__::ValueError("array must not contain infs or NaNs");
                }
                return out;
            }

        PROXY(pythonic::numpy, asarray_chkfinite);

        ALIAS(asarray, ascontiguousarray)
        PROXY(pythonic::numpy, ascontiguousarray);

        template<class E>
            auto asscalar(E const& expr) -> decltype(expr.at(0)) {
                if(expr.size() != 1)
                    throw __builtin__::ValueError("can only convert an array  of size 1 to a Python scalar");
                return expr.at(0);
            }

        PROXY(pythonic::numpy, asscalar);

        template<class T>
            typename std::enable_if<std::is_scalar<T>::value or is_complex<T>::value, core::ndarray<T,1>>::type
            atleast_1d(T t) {
                return core::ndarray<T,1>(core::make_tuple(1L), t);
            }
        template<class T>
            auto atleast_1d(T const& t) -> typename std::enable_if< not(std::is_scalar<T>::value or is_complex<T>::value), typename core::numpy_expr_to_ndarray<T>::type > ::type {
                return asarray(t);
            }

        PROXY(pythonic::numpy, atleast_1d);

        template<class T>
            typename std::enable_if<std::is_scalar<T>::value or is_complex<T>::value, core::ndarray<T,2>>::type
            atleast_2d(T t) {
                return core::ndarray<T,2>(core::make_tuple(1L,1L), t);
            }
        template<class T>
            auto atleast_2d(T const& t)
            -> typename std::enable_if<
                    not(std::is_scalar<T>::value or is_complex<T>::value) and core::numpy_expr_to_ndarray<T>::type::value < 2,
                    core::ndarray<typename core::numpy_expr_to_ndarray<T>::type::dtype,2>
                > ::type
            {
                auto r = asarray(t);
                return r.reshape(core::make_tuple(1L, r.shape[0]));
            }

        template<class T>
            auto atleast_2d(T const& t)
            -> typename std::enable_if<
                    not(std::is_scalar<T>::value or is_complex<T>::value) and core::numpy_expr_to_ndarray<T>::type::value >= 2,
                    decltype(asarray(t))
               > ::type
            {
                return asarray(t);
            }

        PROXY(pythonic::numpy, atleast_2d);

        template<class T>
            typename std::enable_if<std::is_scalar<T>::value or is_complex<T>::value, core::ndarray<T,3>>::type
            atleast_3d(T t) {
                return core::ndarray<T,3>(core::make_tuple(1L,1L,1L), t);
            }
        template<class T>
            auto atleast_3d(T const& t)
            -> typename std::enable_if<
                    not(std::is_scalar<T>::value or is_complex<T>::value) and (core::numpy_expr_to_ndarray<T>::type::value < 3),
                    core::ndarray<typename core::numpy_expr_to_ndarray<T>::type::dtype, 3>
                > ::type
            {
                auto r = asarray(t);
                auto shape = r.shape;
                if(shape.size() == 1)
                    return r.reshape(core::make_tuple(1L, shape[0],1L));
                else
                    return r.reshape(core::make_tuple(shape[0], shape[1], 1L));
            }

        template<class T>
            auto atleast_3d(T const& t)
            -> typename std::enable_if<
                    not(std::is_scalar<T>::value or is_complex<T>::value) and core::numpy_expr_to_ndarray<T>::type::value >= 3,
                    decltype(asarray(t))
               > ::type
            {
                return asarray(t);
            }

        PROXY(pythonic::numpy, atleast_3d);

        template<class E>
            auto average(E const & expr, none_type const& axis=None) -> decltype(sum(expr, axis)/1.) {
                return sum(expr, axis) / double(expr.size());
            }

        template<class E>
            auto average(E const & expr, long axis) -> decltype(sum(expr, axis)/1.) {
                auto shape = expr.shape;
                return sum(expr, axis) / double(shape[axis]);
            }

        template<class E, class W>
            auto average(E const & expr, none_type const& axis, W&& weights) -> decltype(average(expr * asarray(weights) / average(asarray(weights)))) {
                auto aweights = asarray(weights);
                auto weighted_expr = expr * aweights / average(aweights) ;
                return average(weighted_expr) ;
            }

        PROXY(pythonic::numpy, average);

        namespace {

            char *int2bin(long a, char *buffer, int buf_size) {
                buffer += (buf_size - 1);
                buffer[1]=0;
                for (int i = 0; i < buf_size; ++i) {
                    *buffer-- = (a & 1) + '0';
                    a >>= 1;
                }
                return buffer;
            }

            char* itoa( int value, char* result, int base ) {
                // check that the base if valid
                if (base < 2 || base > 16) { *result = 0; return result; }

                char* out = result;
                int quotient = abs(value);

                do {
                    const int tmp = quotient / base;
                    *out = "0123456789ABCDEF"[ quotient - (tmp*base) ];
                    ++out;
                    quotient = tmp;
                } while ( quotient );

                // Apply negative sign
                if ( value < 0) *out++ = '-';

                std::reverse( result, out );
                *out = 0;
                return result;
            }

        }

        core::string base_repr(long number, long base=2, long padding=0) {
            char * mem = new char[sizeof(number)*8+1 + padding];
            std::fill(mem, mem+padding, '0');
            itoa(number, mem + padding, base);
            auto res = core::string(mem);
            delete [] mem;
            return res;
        }

        PROXY(pythonic::numpy, base_repr);

        core::string binary_repr(long number, none_type width=None) {
            return base_repr(number,2);
        }

        core::string binary_repr(long number, long width) {
            core::string out = binary_repr(std::abs(number));
            if(number>=0) {
                return base_repr(std::abs(number), 2, width - out.size());
            }
            else {
                char * mem = new char[width+1];
                int2bin(number, mem, width);
                auto res = core::string(mem);
                delete [] mem;
                return res;
            }
        }

        PROXY(pythonic::numpy, binary_repr);

        template<class T, size_t N>
            core::ndarray<long,1> bincount(core::ndarray<T,N> const & expr, none_type weights=None, none<long> minlength = None) {
                long length = 0;
                if(minlength) length = (long)minlength;
                length = std::max(length, 1 + max(expr));
                core::ndarray<long, 1> out( core::make_tuple(length), 0L);
                long n = expr.size();
                for(long i=0; i < n; i++)
                    ++out[ expr.at(i) ];
                return out;
            }

        template<class T, size_t N, class E>
            core::ndarray<decltype(std::declval<long>()*std::declval<E>().at(0)),1> bincount(core::ndarray<T,N> const & expr, E const& weights, none<long> minlength = None) {
                long length = 0;
                if(minlength) length = (long)minlength;
                length = std::max(length, 1 + max(expr));
                core::ndarray<decltype(std::declval<long>()*std::declval<E>().at(0)), 1> out( core::make_tuple(length), 0L);
                long n = expr.size();
                for(long i=0; i < n; i++)
                    out[ expr.at(i) ] += weights.at(i);
                return out;
            }

        PROXY(pythonic::numpy, bincount);

        template<class E, class Mi, class Ma>
            typename core::numpy_expr_to_ndarray<E>::type clip(E const& e, Mi a_min, Ma a_max) {
                typename core::numpy_expr_to_ndarray<E>::type out(e.shape, None);
                auto out_iter = out.buffer;
                for(long i=0, n=e.size(); i<n; i++) {
                    auto v = e.at(i);
                    if(v<a_min) v=a_min;
                    else if(v>a_max) v = a_max;
                    *out_iter++ = v;
                }
                return out;
            }

        PROXY(pythonic::numpy, clip);

        template<class T, size_t N, size_t M>
            core::ndarray<T,N> concatenate(core::ltuple<core::ndarray<T,N>, M> const & ai) {
                long n = 1;
                long shape[N];
                shape[0] = 0L;
                for(auto const& a : ai) {
                    shape[0] += a.shape[0];
                    n *= a.size();
                }
                std::copy(ai[0].shape.begin() +1 , ai[0].shape.end(), &shape[1]);

                T* buffer = new T[n];
                T* iter = buffer;
                for(auto const& a : ai) 
                    iter = std::copy(a.buffer, a.buffer + a.size(), iter);

                return core::ndarray<T,N>(buffer, shape, n);
            }
        PROXY(pythonic::numpy, concatenate);

        template<class T, size_t N>
            core::ndarray<T,N> copy(core::ndarray<T,N> const& a) {
                auto res = core::ndarray<T,N>(a.shape, None);
                std::copy(a.buffer, a.buffer + a.size(), res.buffer);
                return res;
            }
        PROXY(pythonic::numpy, copy);

        template<class T, size_t N, class dtype=T>
            core::ndarray<dtype,1> cumprod(core::ndarray<T,N> const& expr, dtype d = dtype()) {
                long count = expr.size();
                core::ndarray<dtype,1> cumprody(core::make_tuple(count), None);
                std::partial_sum(expr.buffer, expr.buffer + count, cumprody.buffer, std::multiplies<T>());
                return cumprody;
            }

        template<class T, class dtype=T>
            core::ndarray<dtype,1> cumprod(core::ndarray<T,1> const& expr, long axis, dtype d = dtype()) {
                if(axis !=0)
                    throw __builtin__::ValueError("axis out of bounds");
                return cumprod(expr);
            }

        template<class T, size_t N, class dtype=T>
            core::ndarray<dtype,N> cumprod(core::ndarray<T,N> const& expr, long axis, dtype d = dtype()) {
                if(axis<0 || axis >=long(N))
                    throw __builtin__::ValueError("axis out of bounds");

                auto shape = expr.shape;
                core::ndarray<dtype,N> cumprody(shape, None);
                if(axis==0) {
                    std::copy(expr.buffer, expr.buffer + shape[N-1], cumprody.buffer);
                    std::transform(cumprody.begin(), cumprody.end()-1, expr.begin() + 1, cumprody.begin() + 1, std::multiplies<core::ndarray<T,N-1>>());
                }
                else {
                    std::transform(expr.begin(), expr.end(), cumprody.begin(), [=](core::ndarray<T,N-1> const& e) { return cumprod(e, axis-1, d); });
                }
                return cumprody;
            }

        ALIAS(cumprod, cumproduct)
        PROXY(pythonic::numpy, cumproduct);
        PROXY(pythonic::numpy, cumprod);

        template<class T, size_t N>
            core::ndarray<T,1> delete_(core::ndarray<T,N> const& a, long index, none_type axis=None) {
                core::ndarray<T,1> out(core::make_tuple(long(a.size())-1), None);
                long n = a.size();
                index = std::min(n, index);
                std::copy(a.buffer + index + 1 , a.buffer + n, std::copy(a.buffer, a.buffer + index, out.buffer));
                return out;
            }

        template<class T, size_t N, class I>
            typename std::enable_if<!std::is_scalar<I>::value, core::ndarray<T,1>>::type
            delete_(core::ndarray<T,N> const& in, I const& indices, none_type axis=None) {
                core::ndarray<T,1> out(core::make_tuple(long(in.size())-indices.size()), None);
                auto out_iter = out.buffer;
                auto in_iter = in.buffer;
                for(long index : indices) {
                    out_iter = std::copy(in_iter, in.buffer + index, out_iter);
                    in_iter = in.buffer + index + 1;
                }
                std::copy(in_iter, in.buffer + in.size(), out_iter);
                return out;
            }

        PROXY(pythonic::numpy, delete_);

        template<class T>
            core::ndarray<T,1> diag(core::ndarray<T,2> a, long k=0) {
                T* buffer = new T[std::max(a.shape[0], a.shape[1])];
                long shape[1] = {0};
                auto iter = buffer;
                if(k>=0)
                    for(int i=0, j = k; i< a.shape[0] and j < a.shape[1]; ++i, ++j, ++shape[0])
                        *iter++ = a[i][j];
                else {
                    for(int i=-k, j = 0; i< a.shape[0] and j < a.shape[1]; ++i, ++j, ++shape[0])
                        *iter++ = a[i][j];
                }
                return core::ndarray<T,1>(buffer, shape, shape[0]);
            }

        template<class T>
            core::ndarray<T,2> diag(core::ndarray<T,1> a, long k=0) {
                long n = a.size() + std::abs(k);
                core::ndarray<T,2> out(core::make_tuple(n,n), 0);
                if(k>=0)
                    for(long i=0,j =k ; i< n and j<n ;++i,++j)
                        out[i][j] = a.buffer[i];
                else
                    for(long i=-k,j =0 ; i< n and j<n ;++i,++j)
                        out[i][j] = a.buffer[j];
                return out;
            }
        template<class T>
            auto diag(core::list<T> const& t, long k=0) 
            -> decltype(diag(asarray(t),k))
            {
                return diag(asarray(t),k);
            }

        PROXY(pythonic::numpy, diag);

        ALIAS(diag, diagflat);
        PROXY(pythonic::numpy, diagflat);

        ALIAS(diag, diagonal);
        PROXY(pythonic::numpy, diagonal);

        template<class E>
            typename core::numpy_expr_to_ndarray<E>::type
            diff(E const& expr, long n=1) {
                decltype(expr.shape) shape(expr.shape.begin(), expr.shape.end());
                --shape[core::numpy_expr_to_ndarray<E>::N-1];

                typename core::numpy_expr_to_ndarray<E>::type out(shape, None);
                auto slice = expr.shape[-1];
                long j = 0;
                for(long i = 0, n = expr.size(); i< n ; i+=slice) {
                    auto prev = expr.at(i);
                    for(long k = 1; k< slice ; ++k) {
                        auto nprev = expr.at(i+k);
                        out.at(j++) = nprev - prev;
                        prev = nprev;
                    }
                }
                if(n==1) return out;
                else return diff(out, n-1); // TODO: inplace modification to avoid n-1 allcoations
            }

        PROXY(pythonic::numpy, diff);

        template<class E, class F>
            core::ndarray< long, 1 >
            digitize(E const& expr, F const& b) {
                auto bins = asarray(b);
                bool is_increasing = bins.size() > 1 and bins.at(0) < bins.at(1);
                core::ndarray<long, 1> out(core::make_tuple(long(expr.size())), None);
                if(is_increasing) {
                    for(long i = 0, n = expr.size(); i< n; ++i)
                        out.at(i) = std::lower_bound(bins.begin(), bins.end(), expr.at(i)) - bins.begin();
                }
                else {
                    for(long i = 0, n = expr.size(); i< n; ++i)
                        out.at(i) = std::lower_bound(bins.begin(), bins.end(), expr.at(i), operator_::proxy::gt()) - bins.begin();
                }
                return out;
            }

        PROXY(pythonic::numpy, digitize);

        template<class E, class F>
            typename std::enable_if<
                (std::is_scalar<E>::value or is_complex<E>::value) and (std::is_scalar<F>::value or is_complex<F>::value),
                decltype(std::declval<E>()*std::declval<F>())
            >::type
            dot(E const& e, F const& f)
            {
                return e*f;
            }

        template<class E, class F>
            typename std::enable_if<
                core::is_array<E>::value and core::is_array<F>::value and
                core::numpy_expr_to_ndarray<E>::N == 1 and core::numpy_expr_to_ndarray<F>::N ==1,
                decltype(std::declval<typename core::numpy_expr_to_ndarray<E>::type::dtype>()*std::declval<typename core::numpy_expr_to_ndarray<F>::type::dtype>())
            >::type
            dot(E const& e, F const& f) {
                return sum(e*f);
            }

        template<class E, class F>
            typename std::enable_if<
                (std::is_scalar<E>::value or is_complex<E>::value) and (std::is_scalar<E>::value or is_complex<E>::value),
                decltype(std::declval<E>()*std::declval<F>())
            >::type
            dot(core::list<E> const& e, core::list<F> const& f) {
                return dot(asarray(e), asarray(f));
            }

        template<class E, class F>
            typename std::enable_if<
                (std::is_scalar<E>::value or is_complex<E>::value) and
                core::is_array<F>::value and core::numpy_expr_to_ndarray<F>::N ==1,
                decltype(std::declval<E>()*std::declval<typename core::numpy_expr_to_ndarray<F>::type::dtype>())
            >::type
            dot(F const& f,core::list<E> const& e) {
                return dot(f, asarray(e));
            }

        template<class E, class F>
            typename std::enable_if<
                (std::is_scalar<E>::value or is_complex<E>::value) and
                core::is_array<F>::value and core::numpy_expr_to_ndarray<F>::N ==1,
                decltype(std::declval<E>()*std::declval<typename core::numpy_expr_to_ndarray<F>::type::dtype>())
            >::type
            dot(core::list<E> const& e, F const& f) {
                return dot(asarray(e), f);
            }

        PROXY(pythonic::numpy, dot);

        template<class E>
            core::ndarray<typename core::numpy_expr_to_ndarray<E>::type::dtype, 1>
            ediff1d(E const& expr)
            {
                long n = expr.size() -1 ;
                core::ndarray<typename core::numpy_expr_to_ndarray<E>::type::dtype, 1> out(core::make_tuple(n), None);
                auto prev = expr.at(0);
                for(long i=0; i< n ; ++i) {
                    auto next = expr.at(i+1);
                    out.at(i) = next - prev;
                    prev = next;
                }
                return out;
            }

        template<class E>
            auto ediff1d(core::list<E> const & expr) -> decltype(ediff1d(asarray(expr))) {
                return ediff1d(asarray(expr));
            }

        PROXY(pythonic::numpy, ediff1d);

        template<class dtype = double>
            core::ndarray<dtype, 2> eye(long N, long M=-1, long k=0, dtype d=dtype())
            {
                if(M<0) M = N;
                core::ndarray<dtype, 2> out = zeros(core::make_tuple(N, M), d);
                if(k>=0)
                    for(int i=0, j = k; i< N and j < M; ++i, ++j)
                        out[i][j] = dtype(1);
                else
                    for(int i=-k, j = 0; i< N and j < M; ++i, ++j)
                        out[i][j] = dtype(1);
                return out;
            }

        PROXY(pythonic::numpy, eye);

        template<class dtype=double>
            core::finfo<dtype> finfo(dtype d=dtype()) {
                return core::finfo<dtype>();
            }
        PROXY(pythonic::numpy, finfo)


            template<class E>
            core::ndarray<long, 1> flatnonzero(E const& expr) {
                long n = expr.size();
                long *buffer = new long[n];
                long *iter = buffer;
                for(long i=0;i<n;i++) 
                    if(expr.at(i))
                        *iter++ = i;
                long shape[1] = { iter - buffer };
                return core::ndarray<long, 1>(buffer, shape, shape[0]);
            }
        template<class E>
            auto flatnonzero(core::list<E> const & l)
            -> decltype(flatnonzero(asarray(l)))
            {
                return flatnonzero(asarray(l));
            }

        PROXY(pythonic::numpy, flatnonzero);

        template<class T, size_t N>
            core::ndarray<T,N> fliplr(core::ndarray<T,N> const& a) {
                static_assert(N>=2, "fliplr only works on array of dimension >= 2");
                core::ndarray<T,N> out(a.shape, None);
                std::copy(a.buffer, a.buffer + a.size(), out.buffer);
                for(auto & col : out)
                    std::reverse(col.begin(), col.end());
                return out;
            }

        PROXY(pythonic::numpy, fliplr); // does not return a view...

        template<class T, size_t N>
            core::ndarray<T,N> flipud(core::ndarray<T,N> const& a) {
                core::ndarray<T,N> out(a.shape, None);
                std::reverse_copy(a.begin(), a.end(), out.begin());
                return out;
            }
        PROXY(pythonic::numpy, flipud);

        template<class F, class dtype=double>
            core::ndarray<typename std::remove_cv<typename std::remove_reference<decltype(std::declval<F>()(dtype()))>::type>::type, 1>
            fromfunction(F&& f, core::ltuple<long,1> const& shape, dtype d = dtype()) {
                core::ndarray<typename std::remove_cv<typename std::remove_reference<decltype(f(dtype()))>::type>::type, 1> out(shape, None);
                for(dtype i=0, n= out.shape[0]; i<n; ++i)
                    out[i] = f(i);
                return out;
            }

        template<class F, class dtype=double>
            core::ndarray<typename std::remove_cv<typename std::remove_reference<decltype(std::declval<F>()(dtype(), dtype()))>::type>::type, 2>
            fromfunction(F&& f, core::ltuple<long,2> const& shape, dtype d = dtype()) {
                core::ndarray<typename std::remove_cv<typename std::remove_reference<decltype(f(dtype(), dtype()))>::type>::type, 2> out(shape, None);
                for(dtype i=0, n= out.shape[0]; i<n; ++i)
                    for(dtype j=0, m= out.shape[1]; j<m; ++j)
                        out[i][j] = f(i,j);
                return out;
            }

        /* must specialize for higher order */
        PROXY(pythonic::numpy, fromfunction);

        template<class Iterable, class dtype=double>
            core::ndarray<typename std::remove_cv<typename std::remove_reference<Iterable>::type>::type::value_type, 1>
            fromiter(Iterable&& iterable, dtype d=dtype(), long count = -1)
            {
                typedef typename std::remove_cv<typename std::remove_reference<Iterable>::type>::type::value_type T;
                if(count < 0) {
                    core::list<T> buffer(0);
                    std::copy(iterable.begin(), iterable.end(), std::back_inserter(buffer));
                    return core::ndarray<T,1>(buffer);
                }
                else {
                    T* buffer = new T[count];
                    std::copy_n(iterable.begin(), count, buffer);
                    long shape [1] = { count };
                    return core::ndarray<T,1>(buffer, shape, shape[0]);
                }
            }
        PROXY(pythonic::numpy, fromiter);

        template<class dtype=double>
            core::ndarray<dtype,1> fromstring(core::string const& string, dtype d=dtype(), long count = -1 , core::string const& sep = "") {
                if(sep) {
                    core::list<dtype> res(0);
                    if(count<0) count = std::numeric_limits<long>::max();
                    else res.reserve(count);
                    size_t current;
                    size_t next = -1;
                    long numsplit = 0;
                    do {
                        current = next + 1;
                        next = string.find_first_of( sep, current );
                        dtype item;
                        std::istringstream iss(string.substr( current, next - current ));
                        iss >> item;
                        res.push_back(item);
                    }
                    while (next != core::string::npos && ++numsplit<count);
                    return core::ndarray<dtype, 1>(res);
                }
                else {
                    if(count <0) count = string.size();
                    long shape[1] = { count };
                    dtype* buffer = new dtype[shape[0]];
                    dtype const* tstring = reinterpret_cast<dtype const*>(&string[0]);
                    std::copy(tstring, tstring + shape[0], buffer);
                    return core::ndarray<dtype,1>(buffer, shape, shape[0]);
                }
            }

        PROXY(pythonic::numpy, fromstring);

        template<class dtype=double>
            auto identity(long n, dtype d=dtype()) -> decltype(eye(n,n,0,d)) {
                return eye(n,n,0,d);
            }
        PROXY(pythonic::numpy, identity);

        template<size_t N, class dtype=long>
            core::ndarray<dtype, N+1> indices(core::ltuple<long, N> const& shape, dtype d = dtype()) {
                core::ltuple<long, N+1> oshape;
                oshape[0] = N ;
                std::copy(shape.begin(), shape.end(), oshape.begin() + 1);
                core::ndarray<dtype, N+1> out(oshape, None);
                dtype* iters[N];
                for(size_t n=0; n<N; ++n) 
                    iters[n]=out[n].buffer;
                size_t lens[N];
                lens[0] = out.size() / shape[0];
                for(size_t n=1; n<N; ++n) 
                    lens[n] = lens[n-1] / shape[n];
                for(long i=0, n=out.size()/N; i<n;i++) {
                        long mult = 1;
                        for(long n=N-1; n>0; n--) {
                            *(iters[n]++) = (i/mult)%shape[n];
                            mult *= shape[n];
                        }
                        *(iters[0]++) = i/mult;
                }
                return out;
            }

        PROXY(pythonic::numpy, indices);

        ALIAS(dot, inner); // only for scalar and 1D case
        PROXY(pythonic::numpy, inner);

        template<class T, size_t N, class I, class F>
            typename std::enable_if<is_iterable<I>::value and is_iterable<F>::value, core::ndarray<T,1>>::type
            insert(core::ndarray<T,N> const& in, I const& indices, F const& data, none_type axis=None)
            {
                core::ndarray<T,1> out(core::make_tuple(long(in.size()+std::min(indices.size(), data.size()))), None);
                auto out_iter = out.buffer;
                auto in_iter = in.buffer;
                auto data_iter = data.begin();
                for(long index : indices) {
                    out_iter = std::copy(in_iter, in.buffer + index, out_iter);
                    *out_iter++ = *data_iter++;
                    in_iter = in.buffer + index;
                }
                std::copy(in_iter, in.buffer + in.size(), out_iter);
                return out;
            }
        template<class T, size_t N, class I, class F>
            typename std::enable_if<is_iterable<I>::value and not is_iterable<F>::value, core::ndarray<T,1>>::type
            insert(core::ndarray<T,N> const& in, I const& indices, F const& data, none_type axis=None)
            {
                return insert(in, indices, core::list<F>({data}), axis);
            }
        template<class T, size_t N, class I, class F>
            typename std::enable_if<not is_iterable<I>::value and is_iterable<F>::value, core::ndarray<T,1>>::type
            insert(core::ndarray<T,N> const& in, I const& indices, F const& data, none_type axis=None)
            {
                return insert(in, core::list<I>({indices}), {data}, axis);
            }
        template<class T, size_t N, class I, class F>
            typename std::enable_if<not is_iterable<I>::value and not is_iterable<F>::value, core::ndarray<T,1>>::type
            insert(core::ndarray<T,N> const& in, I const& indices, F const& data, none_type axis=None)
            {
                return insert(in, core::list<I>({indices}), core::list<F>({data}), axis);
            }

        PROXY(pythonic::numpy, insert);

        template<class E, class F>
            core::ndarray<
                decltype(std::declval<typename core::numpy_expr_to_ndarray<E>::type::dtype>()
                        +
                        std::declval<typename core::numpy_expr_to_ndarray<F>::type::dtype>()),
                1>
                    intersect1d(E const& e, F const& f)
                    {
                        typedef decltype(std::declval<typename core::numpy_expr_to_ndarray<E>::type::dtype>()
                                +
                                std::declval<typename core::numpy_expr_to_ndarray<F>::type::dtype>()) T;
                        auto ae = asarray(e);
                        auto af = asarray(f);
                        std::set<T> sae(ae.buffer, ae.buffer + ae.size());
                        std::set<T> found;
                        core::list<T> lout(0);
                        lout.reserve(sae.size());
                        for(long i=0, n = af.size(); i<n; ++i)
                            if(sae.find(af.at(i)) != sae.end() and found.find(af.at(i)) == found.end()) {
                                found.insert(af.at(i));
                                lout.push_back(af.at(i));
                            }
                        std::sort(lout.begin(), lout.end());
                        return core::ndarray<T, 1> (lout);
                    }

        PROXY(pythonic::numpy, intersect1d);

        template<class E>
            typename std::enable_if<
                    is_complex<typename core::numpy_expr_to_ndarray<E>::type::dtype>::value,
                    core::ndarray<bool, core::numpy_expr_to_ndarray<E>::N>
                        >::type
            iscomplex(E const& expr) {
                core::ndarray<bool, core::numpy_expr_to_ndarray<E>::N> out(expr.shape, None);
                for(long i=0, n=expr.size(); i<n; ++i)
                    out.at(i) = expr.at(i).imag();
                return out;
            }

        template<class E>
            typename std::enable_if<
                    not is_complex<typename core::numpy_expr_to_ndarray<E>::type::dtype>::value,
                    core::ndarray<bool, core::numpy_expr_to_ndarray<E>::N>
                        >::type
            iscomplex(E const& expr) {
                return core::ndarray<bool, core::numpy_expr_to_ndarray<E>::N>(expr.shape, false); 
            }

        PROXY(pythonic::numpy, iscomplex);

        template<class E>
            typename std::enable_if<
                    is_complex<typename core::numpy_expr_to_ndarray<E>::type::dtype>::value,
                    core::ndarray<bool, core::numpy_expr_to_ndarray<E>::N>
                        >::type
            isreal(E const& expr) {
                core::ndarray<bool, core::numpy_expr_to_ndarray<E>::N> out(expr.shape, None);
                for(long i=0, n=expr.size(); i<n; ++i)
                    out.at(i) = not expr.at(i).imag();
                return out;
            }

        template<class E>
            typename std::enable_if<
                    not is_complex<typename core::numpy_expr_to_ndarray<E>::type::dtype>::value,
                    core::ndarray<bool, core::numpy_expr_to_ndarray<E>::N>
                        >::type
            isreal(E const& expr) {
                return core::ndarray<bool, core::numpy_expr_to_ndarray<E>::N>(expr.shape, true); 
            }

        PROXY(pythonic::numpy, isreal);

        template<class E>
            constexpr bool isrealobj(E const& expr) {
                return not is_complex<typename core::numpy_expr_to_ndarray<E>::type::dtype>::value ;
            }

        PROXY(pythonic::numpy, isrealobj);

        template<class E>
            constexpr bool isscalar(E const&) {
                return std::is_scalar<E>::value or is_complex<E>::value or std::is_same<E, core::string>::value;
            }
        PROXY(pythonic::numpy, isscalar);

        template<class E>
            constexpr bool issctype(E const& expr) {
                return isscalar(expr); // types are represented as an instance of the type...
            }
        PROXY(pythonic::numpy, issctype);

        template<class K>
            struct lexcmp {
                K const& keys;
                lexcmp(K const& keys) : keys(keys) {
                }
                bool operator()(long i0, long i1) {
                    for(long i= keys.size() -1; i>=0; --i)
                        if(keys[i][i0] < keys[i][i1]) return true;
                        else if(keys[i][i0] > keys[i][i1]) return false;
                    return false;
                }
            };

        template<class T, size_t N>
            core::ndarray<long, 1> lexsort(core::ltuple<T, N> const& keys) {
                long n = keys[0].size();
                core::ndarray<long, 1> out(core::make_tuple(n), None);
                // fill with the original indices
                std::iota(out.buffer, out.buffer + n, 0L);
                // then sort using keys as the comparator
                std::sort(out.buffer, out.buffer +n, lexcmp<core::ltuple<T, N>>(keys));
                return out;
            }
        PROXY(pythonic::numpy, lexsort)

            template<class E>
            auto nonzero(E const& expr) -> core::ltuple<core::ndarray<long,1>, core::numpy_expr_to_ndarray<E>::N>
            {
                constexpr long N = core::numpy_expr_to_ndarray<E>::N;
                typedef core::ltuple<core::ndarray<long,1>, N> out_type;
                long sz = expr.size();
                auto eshape = expr.shape;
                long *buffer = new long[N * sz]; // too much memory used
                long *buffer_iter = buffer;
                long real_sz = 0;
                for(long i=0; i< sz; ++i) {
                    if(expr.at(i)) {
                        ++real_sz;
                        long mult = 1;
                        for(long j=N-1; j>0; j--) {
                            buffer_iter[j] = (i/mult)%eshape[j];
                            mult*=eshape[j];
                        }
                        buffer_iter[0] = i/mult;
                        buffer_iter+=N;
                    }
                }
                out_type out;
                core::ltuple<long, 1> shape{ real_sz };
                for(long i=0; i<N; i++)
                {
                    out[i] = core::ndarray<long, 1>(shape, None);
                    for(long j=0; j<real_sz; j++)
                        out[i][j] = buffer[j * N + i];
                }
                return out;
            }

        PROXY(pythonic::numpy, nonzero)

        /* cas : array_like, array_like, array_like */
        template<class E, class X, class Y>
            typename std::enable_if<core::is_array_like<typename std::remove_reference<typename std::remove_cv<E>::type>::type>::value && 
            core::is_array_like<typename std::remove_reference<typename std::remove_cv<X>::type>::type>::value &&
            core::is_array_like<typename std::remove_reference<typename std::remove_cv<Y>::type>::type>::value,
            core::ndarray<decltype(std::declval<typename nested_container_value_type<typename std::remove_reference<typename std::remove_cv<X>::type>::type, !core::is_array_like<typename std::remove_reference<typename std::remove_cv<X>::type>::type>::value>::type>() + std::declval<typename nested_container_value_type<typename std::remove_reference<typename std::remove_cv<Y>::type>::type, !core::is_array_like<typename std::remove_reference<typename std::remove_cv<Y>::type>::type>::value>::type>()), nested_container_depth<typename std::conditional<core::is_array_like<typename std::remove_reference<typename std::remove_cv<E>::type>::type>::value, typename std::remove_reference<typename std::remove_cv<E>::type>::type, bool>::type>::value>
                >::type where(E const& e, X const& x, Y const& y) {
                    auto condition = asarray(e);
                    auto x_ = asarray(x);
                    auto y_ = asarray(y);
                    core::ndarray<decltype(std::declval<typename nested_container_value_type<typename std::remove_reference<typename std::remove_cv<X>::type>::type>::type>() + std::declval<typename nested_container_value_type<typename std::remove_reference<typename std::remove_cv<Y>::type>::type>::type>()), nested_container_depth<typename std::remove_reference<typename std::remove_cv<E>::type>::type>::value> out(condition.shape, None);
                    auto out_iter = out.buffer;
                    for(long i=0, n=condition.size(); i<n; i++) {
                        if(condition.at(i))
                            *out_iter++ = x_.at(i);
                        else
                            *out_iter++ = y_.at(i);
                    }
                    return out;
                }

        /* cas : array_like, value, array_like */
        template<class E, class X, class Y>
            typename std::enable_if<core::is_array_like<typename std::remove_reference<typename std::remove_cv<E>::type>::type>::value && 
            !core::is_array_like<typename std::remove_reference<typename std::remove_cv<X>::type>::type>::value &&
            core::is_array_like<typename std::remove_reference<typename std::remove_cv<Y>::type>::type>::value,
            core::ndarray<decltype(std::declval<X>() + std::declval<typename nested_container_value_type<typename std::remove_reference<typename std::remove_cv<Y>::type>::type, !core::is_array_like<typename std::remove_reference<typename std::remove_cv<Y>::type>::type>::value>::type>()), nested_container_depth<typename std::conditional<core::is_array_like<typename std::remove_reference<typename std::remove_cv<E>::type>::type>::value, typename std::remove_reference<typename std::remove_cv<E>::type>::type, bool>::type>::value>
                >::type where(E const& e, X const& x, Y const& y) {
                    auto condition = asarray(e);
                    auto y_ = asarray(y);
                    core::ndarray<decltype(std::declval<X>() + std::declval<typename nested_container_value_type<typename std::remove_reference<typename std::remove_cv<Y>::type>::type>::type>()), nested_container_depth<typename std::remove_reference<typename std::remove_cv<E>::type>::type>::value> out(condition.shape, None);
                    auto out_iter = out.buffer;
                    for(long i=0, n=condition.size(); i<n; i++) {
                        if(condition.at(i))
                            *out_iter++ = x;
                        else
                            *out_iter++ = y_.at(i);
                    }
                    return out;
                }

        /* cas : array_like, array_like, value */
        template<class E, class X, class Y>
            typename std::enable_if<core::is_array_like<typename std::remove_reference<typename std::remove_cv<E>::type>::type>::value && 
            core::is_array_like<typename std::remove_reference<typename std::remove_cv<X>::type>::type>::value &&
            !core::is_array_like<typename std::remove_reference<typename std::remove_cv<Y>::type>::type>::value,
            core::ndarray<decltype(std::declval<Y>() + std::declval<typename nested_container_value_type<typename std::remove_reference<typename std::remove_cv<X>::type>::type, !core::is_array_like<typename std::remove_reference<typename std::remove_cv<X>::type>::type>::value>::type>()), nested_container_depth<typename std::conditional<core::is_array_like<typename std::remove_reference<typename std::remove_cv<E>::type>::type>::value, typename std::remove_reference<typename std::remove_cv<E>::type>::type, bool>::type>::value>
                >::type where(E const& e, X const& x, Y const& y) {
                    auto condition = asarray(e);
                    auto x_ = asarray(x);
                    core::ndarray<decltype(std::declval<Y>() + std::declval<typename nested_container_value_type<typename std::remove_reference<typename std::remove_cv<X>::type>::type>::type>()), nested_container_depth<typename std::remove_reference<typename std::remove_cv<E>::type>::type>::value> out(condition.shape, None);
                    auto out_iter = out.buffer;
                    for(long i=0, n=condition.size(); i<n; i++) {
                        if(condition.at(i))
                            *out_iter++ = x_.at(i);
                        else
                            *out_iter++ = y;
                    }
                    return out;
                }

        /* cas : array_like, value, value */
        template<class E, class X, class Y>
            typename std::enable_if<core::is_array_like<typename std::remove_reference<typename std::remove_cv<E>::type>::type>::value && 
            !core::is_array_like<typename std::remove_reference<typename std::remove_cv<X>::type>::type>::value &&
            !core::is_array_like<typename std::remove_reference<typename std::remove_cv<Y>::type>::type>::value,
            core::ndarray<decltype(std::declval<Y>() + std::declval<X>()), nested_container_depth<typename std::conditional<core::is_array_like<typename std::remove_reference<typename std::remove_cv<E>::type>::type>::value, typename std::remove_reference<typename std::remove_cv<E>::type>::type, bool>::type>::value>
                >::type where(E const& e, X const& x, Y const& y) {
                    auto condition = asarray(e);
                    core::ndarray<decltype(std::declval<Y>() + std::declval<X>()), nested_container_depth<typename std::remove_reference<typename std::remove_cv<E>::type>::type>::value> out(condition.shape, None);
                    auto out_iter = out.buffer;
                    for(long i=0, n=condition.size(); i<n; i++) {
                        if(condition.at(i))
                            *out_iter++ = x;
                        else
                            *out_iter++ = y;
                    }
                    return out;
                }

        /* cas : value, value, array_like */
        template<class E, class X, class Y>
            typename std::enable_if<!core::is_array_like<typename std::remove_reference<typename std::remove_cv<E>::type>::type>::value && 
            !core::is_array_like<typename std::remove_reference<typename std::remove_cv<X>::type>::type>::value &&
            core::is_array_like<typename std::remove_reference<typename std::remove_cv<Y>::type>::type>::value,
            core::ndarray<decltype(std::declval<X>() + std::declval<typename nested_container_value_type<typename std::remove_reference<typename std::remove_cv<Y>::type>::type, !core::is_array_like<typename std::remove_reference<typename std::remove_cv<Y>::type>::type>::value>::type>()), nested_container_depth<typename std::conditional<core::is_array_like<typename std::remove_reference<typename std::remove_cv<Y>::type>::type>::value, typename std::remove_reference<typename std::remove_cv<Y>::type>::type, bool>::type>::value>
                >::type where(E const& e, X const& x, Y const& y) {
                    auto y_ = asarray(y);
                    if(e)
                        return core::ndarray<decltype(std::declval<X>() + std::declval<typename nested_container_value_type<typename std::remove_reference<typename std::remove_cv<Y>::type>::type>::type>()), nested_container_depth<typename std::remove_reference<typename std::remove_cv<Y>::type>::type>::value>(y_.shape, x);
                    else
                        return copy(y_);
                }

        /* cas : value, array_like, value */
        template<class E, class X, class Y>
            typename std::enable_if<!core::is_array_like<typename std::remove_reference<typename std::remove_cv<E>::type>::type>::value && 
            core::is_array_like<typename std::remove_reference<typename std::remove_cv<X>::type>::type>::value &&
            !core::is_array_like<typename std::remove_reference<typename std::remove_cv<Y>::type>::type>::value,
            core::ndarray<decltype(std::declval<Y>() + std::declval<typename nested_container_value_type<typename std::remove_reference<typename std::remove_cv<X>::type>::type, !core::is_array_like<typename std::remove_reference<typename std::remove_cv<X>::type>::type>::value>::type>()), nested_container_depth<typename std::conditional<core::is_array_like<typename std::remove_reference<typename std::remove_cv<X>::type>::type>::value, typename std::remove_reference<typename std::remove_cv<X>::type>::type, bool>::type>::value>
                >::type where(E const& e, X const& x, Y const& y) {
                    auto x_ = asarray(x);
                    if(e)
                        return copy(x_);
                    else
                        return core::ndarray<decltype(std::declval<Y>() + std::declval<typename nested_container_value_type<typename std::remove_reference<typename std::remove_cv<X>::type>::type>::type>()), nested_container_depth<typename std::remove_reference<typename std::remove_cv<X>::type>::type>::value>(x_.shape, y);
                }

        /* cas : value, array_like, array_like */
        template<class E, class X, class Y>
            typename std::enable_if<!core::is_array_like<typename std::remove_reference<typename std::remove_cv<E>::type>::type>::value && 
            core::is_array_like<typename std::remove_reference<typename std::remove_cv<X>::type>::type>::value &&
            core::is_array_like<typename std::remove_reference<typename std::remove_cv<Y>::type>::type>::value,
            core::ndarray<decltype(std::declval<typename nested_container_value_type<typename std::remove_reference<typename std::remove_cv<Y>::type>::type, !core::is_array_like<typename std::remove_reference<typename std::remove_cv<Y>::type>::type>::value>::type>() + std::declval<typename nested_container_value_type<typename std::remove_reference<typename std::remove_cv<X>::type>::type, !core::is_array_like<typename std::remove_reference<typename std::remove_cv<X>::type>::type>::value>::type>()), nested_container_depth<typename std::conditional<core::is_array_like<typename std::remove_reference<typename std::remove_cv<X>::type>::type>::value, typename std::remove_reference<typename std::remove_cv<X>::type>::type, bool>::type>::value>
                >::type where(E const& e, X const& x, Y const& y) {
                    if(e)
                        return copy(asarray(x));
                    else
                        return copy(asarray(y));
                }

        template<class E>
            auto where(E const& expr) -> core::ltuple<core::ndarray<long,1>, core::numpy_expr_to_ndarray<E>::N>
            {
                return nonzero(expr);
            }

        PROXY(pythonic::numpy, where)

        template<class E>
            core::ndarray<double, core::numpy_expr_to_ndarray<E>::N> unwrap(E const& expr, double discont = pi)
            {
                discont = nt2::max(discont, pi);
                core::ndarray<double, core::numpy_expr_to_ndarray<E>::N> out(expr.shape, None);
                out.buffer[0] = expr.at(0);
                for(size_t i=1; i<out.size(); i++)
                {
                    auto val = expr.at(i);
                    if(nt2::abs(out.buffer[i-1] - val) > discont)
                        out.buffer[i] = val + 2*pi * int((out.buffer[i-1] - val) / (discont));
                    else
                        out.buffer[i] = val;
                }
                return out;
            }

        PROXY(pythonic::numpy, unwrap)

        template<class E>
            core::ndarray<typename core::numpy_expr_to_ndarray<E>::T, 1> unique(E const& expr) {
                std::set<typename core::numpy_expr_to_ndarray<E>::T> res;
                for(size_t i=0; i<expr.size(); i++)
                    res.insert(expr.at(i));
                return core::ndarray<typename core::numpy_expr_to_ndarray<E>::T, 1>(res);
            }

        template<class E>
            std::tuple<core::ndarray<typename core::numpy_expr_to_ndarray<E>::T, 1>, core::ndarray<long, 1>> unique(E const& expr, bool return_index) {
                std::set<typename core::numpy_expr_to_ndarray<E>::T> res;
                std::vector<long> return_index_res;
                for(size_t i=0; i<expr.size(); i++)
                {
                    std::pair<typename std::set<typename core::numpy_expr_to_ndarray<E>::T>::iterator, bool> pair = res.insert(expr.at(i));
                    if(pair.second)
                        return_index_res.push_back(i);
                }
                return std::make_tuple(core::ndarray<typename core::numpy_expr_to_ndarray<E>::T, 1>(res), core::ndarray<long, 1>(return_index_res));
            }

        template<class E>
            std::tuple<core::ndarray<typename core::numpy_expr_to_ndarray<E>::T, 1>, core::ndarray<long, 1>, core::ndarray<long, 1>> unique(E const& expr, bool return_index, bool return_inverse) {
                std::set<typename core::numpy_expr_to_ndarray<E>::T> res;
                std::vector<long> return_index_res;
                core::ndarray<long, 1> return_inverse_res(core::ltuple<long, 1>({expr.size()}), None);
                for(int i=0; i<expr.size(); i++)
                {
                    auto pair = res.insert(expr.at(i));
                    return_inverse_res[i] = std::distance(res.begin(), pair.first);
                    if(pair.second)
                        return_index_res.push_back(i);
                }
                return std::make_tuple(core::ndarray<typename core::numpy_expr_to_ndarray<E>::T, 1>(res), core::ndarray<long, 1>(return_index_res), return_inverse_res);
            }

        PROXY(pythonic::numpy, unique)

        NP_PROXY_ALIAS(arccos, nt2::acos);

        NP_PROXY_ALIAS(arccosh, nt2::acosh);

        NP_PROXY_ALIAS(arcsin, nt2::asin);

        NP_PROXY_ALIAS(arcsinh, nt2::asinh);

        NP_PROXY_ALIAS(arctan, nt2::atan);

        NP_PROXY_ALIAS(arctan2, nt2::atan2);

        NP_PROXY_ALIAS(arctanh, nt2::atanh);

        NP_PROXY_OP(bitwise_and);

        NP_PROXY_OP(bitwise_not);

        NP_PROXY_OP(bitwise_or);

        NP_PROXY_OP(bitwise_xor);

        NP_PROXY(ceil);

        NP_PROXY(conj);

        NP_PROXY_ALIAS(conjugate, nt2::conj);

        NP_PROXY(copysign);

        NP_PROXY(cos);

        NP_PROXY(cosh);

        NP_PROXY_ALIAS(deg2rad, nt2::inrad);

        NP_PROXY_ALIAS(degrees, nt2::indeg);

        NP_PROXY_OP(divide);

        NP_PROXY_ALIAS(empty_like, pythonic::numpy_expr::ops::empty_like);

        NP_PROXY_OP(equal);

        NP_PROXY(exp);

        NP_PROXY(expm1);

        NP_PROXY_ALIAS(fabs, nt2::abs);

        NP_PROXY(floor);

        NP_PROXY_ALIAS(floor_divide, nt2::divfloor);

        NP_PROXY_ALIAS(fmax, nt2::max);

        NP_PROXY_ALIAS(fmin, nt2::min);

        NP_PROXY_ALIAS(fmod, nt2::mod);

        // NP_PROXY(frexp); // TODO

        NP_PROXY_OP(greater);

        NP_PROXY_OP(greater_equal);

        NP_PROXY(hypot);

        NP_PROXY_ALIAS(invert, pythonic::numpy_expr::ops::bitwise_not); 

        NP_PROXY_ALIAS(isfinite, nt2::is_finite);

        NP_PROXY_ALIAS(isinf, nt2::is_inf);

        NP_PROXY_ALIAS(isnan, nt2::is_nan);

        NP_PROXY_ALIAS(isneginf, pythonic::numpy_expr::ops::isneginf); 

        NP_PROXY_ALIAS(isposinf, pythonic::numpy_expr::ops::isposinf); 

        NP_PROXY(ldexp);

        NP_PROXY_OP(left_shift);

        NP_PROXY_OP(less);

        NP_PROXY_OP(less_equal);

        NP_PROXY(log10);

        NP_PROXY(log1p);

        NP_PROXY(log2);

        NP_PROXY_ALIAS(logaddexp, pythonic::numpy_expr::ops::logaddexp);

        NP_PROXY_ALIAS(logaddexp2, pythonic::numpy_expr::ops::logaddexp2);

        NP_PROXY_OP(logical_and);

        NP_PROXY_OP(logical_not);

        NP_PROXY_OP(logical_or);

        NP_PROXY_OP(logical_xor);

        NP_PROXY_ALIAS(maximum, nt2::max);

        NP_PROXY_ALIAS(minimum, nt2::min);

        NP_PROXY(mod);

        NP_PROXY_OP(multiply);

        NP_PROXY_OP(negative);

        NP_PROXY(nextafter);

        NP_PROXY_OP(not_equal);

        NP_PROXY_ALIAS(ones_like, pythonic::numpy_expr::ops::ones_like);

        NP_PROXY_ALIAS(power, nt2::pow);

        NP_PROXY_ALIAS(rad2deg, nt2::indeg);

        NP_PROXY_ALIAS(radians, nt2::inrad);

        NP_PROXY_ALIAS(reciprocal, nt2::rec);

        NP_PROXY(remainder);

        NP_PROXY_OP(right_shift);

        NP_PROXY_ALIAS(rint, nt2::iround)

        NP_PROXY(sign);

        NP_PROXY_ALIAS(signbit, nt2::bitofsign)

        NP_PROXY(sin);

        NP_PROXY(sinh);

        NP_PROXY_ALIAS(spacing, nt2::eps)

        NP_PROXY(sqrt);

        NP_PROXY_ALIAS(square, pythonic::numpy_expr::ops::square);

        NP_PROXY_ALIAS(subtract, pythonic::numpy_expr::ops::subtract);

        NP_PROXY(tan);

        NP_PROXY(tanh);

        NP_PROXY_ALIAS(true_divide, pythonic::numpy_expr::ops::divide); 

        NP_PROXY(trunc);

        ALIAS(trunc, fix);
        PROXY(pythonic::numpy, fix);

        NP_PROXY_ALIAS(zeros_like, pythonic::numpy_expr::ops::zeros_like);

#undef NP_PROXY
#undef NAMED_OPERATOR
#undef NAMED_UOPERATOR
    }
}

#endif
